#### 데이터 타입
- Numeric Types
    - int (정수), float (실수), complex (복소수)
- Sequence Types
    - list, tuple, range
- Text Sequence Type
    - str (문자열)
- Set Types
    - set
- Mapping Types
    - dict
- 기타
    - None, Boolean, Functions

#### 데이터 타입이 필요한 이유
- 값들을 구분하고, 어떻게 다뤄야 하는지를 알 수 있음
- 요리 재료마다 특정한 도구가 필요하듯이 각 데이터 타입 값들도 각자에게 적합한 도구를 가짐
- 타입을 명시적으로 지정하면 코드를 읽는 사람이 변수의 의도를 더 쉽게 이해할 수 있고, 잘못된 데이터 타입으로 인한 오류를 미리 예방

#### 연산자 우선순위
| 우선순위 | 연산자         | 연산                   |
|:----:|:-----------:|:--------------------:|
| 높음   | **          | 지수                   |
|      | -           | 음수 부호                |
|      | *, /, //, % | 곱셈, 나눗셈, 정수 나눗셈, 나머지 |
| 낮음   | +, -        | 덧셈, 뺄셈               |

#### 실수 연산 시 주의사항
- 컴퓨터는 2진수를 사용, 사람은 10진법을 사용
- 이때 10진수 0.1은 2진수로 표현하면 0.0001100110011001100110... - 같이 무한대로 반복
- 무한대 숫자를 그대로 저장할 수 없어서 사람이 사용하는 10진법의 근사값만 표시
- 0.1의 경우 3602879701896397 / 2 ** 55 이며 0.1에 가깝지만 정확히 동일하지는 않음
- 이런 과정에서 예상치 못한 결과가 나타남
- 이런 증상을 <span style='color:red;'>Floating point rounding error</span>라고 함

## Sequence Types
### Sequence Types
여러 개의 값들을 <span style='color:red;'>순서대로 나열</span>하여 저장하는 자료형
(str, list, tuple, range)

#### Sequence Type 특징
1. 순서(Sequence)
    - 값들이 순서대로 저장 (정렬 X)
2. 인덱싱(Indexing)
    - 각 값에 고유한 인덱스(번호)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수 있음
3. 슬라이싱(Slicing)
    - 인덱스 범위를 조절해 부분적인 값을 추출할 수 있음
4. 길이(Length)
    - len() 함수를 사용하여 저장된 값의 개수(길이)를 구할 수 있음
5. 반복(Iteration)
    - 반목문을 사용하여 저장된 값들을 반복적으로 처리할 수 있음

#### Escape sequence
- 역슬래시(backslash)뒤에 특정 문자가 와서 특수한 기능을 하는 문자 조합
- 파이썬의 일반적인 문법 규칙을 잠시 탈출한다는 의미

|     예약   문자    	|      내용(의미)    	|
|:------------------:	|:------------------:	|
|          \n        	|      줄   바꿈     	|
|          \t        	|          탭        	|
|          \\        	|       백슬래시     	|
|          \’        	|     작은 따옴표    	|
|          \"        	|     큰   따옴표    	|

## Non-sequence Types
### dict `딕셔너리`
key - value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형

#### 딕셔너리 표현
- key는 변경 불가능한 자료형만 사용 가능 (str, int, float, tuple, range …)
- value는 모든 자료형 사용 가능

### set `세트`
순서와 중복이 없는 변경 가능한 자료형 `my_set = {}`

## Collection
### Collection
여러 개의 항목 또는 요소를 담는 자료 구조
str, list, tuple, set, dict

#### 컬렉션 정리
|     컬렉션    	|     변경 가능 여부    	|     순서 여부    	|          	|
|:-------------:	|:---------------------:	|:----------------:	|:--------:	|
|       str     	|            X          	|         O        	|  시퀀스  	|
|      list     	|            O          	|         O        	|  시퀀스  	|
|      tuple    	|            X          	|         O        	|  시퀀스  	|
|       set     	|            O          	|         X        	| 비시퀀스 	|
|      dict     	|            O          	|         X        	| 비시퀀스 	|

### 암시적 형변환 `Implicit Type conversion`
파이썬이 자동으로 형변환을 하는 것
Boolean과 Numeric Type에서만 가능

### 명시적 형변환 `Explicit Type conversion`
개발자가 직접 형변환을 하는 것 암시적 형변환이 아닌 경우를 모두 포함
#### 명시적 형변환 예시
- str -> integer : 형식에 맞는 숫자만 가능
- integer -> str : 모두 가능

#### 컬렉션 간 형변환 정리
|              	|     str    	|           list         	|         tuple        	|     range    	|          set         	|     dict    	|
|:------------:	|:----------:	|:----------------------:	|:--------------------:	|:------------:	|:--------------------:	|:-----------:	|
|      str     	|            	|            O           	|           O          	|       X      	|           O          	|       X     	|
|      list    	|      O     	|                        	|           O          	|       X      	|           O          	|       X     	|
|     tuple    	|      O     	|            O           	|                      	|       X      	|           O          	|       X     	|
|     range    	|      O     	|            O           	|           O          	|              	|           O          	|       X     	|
|      set     	|      O     	|            O           	|           O          	|       X      	|                      	|       X     	|
|      dict    	|      O     	|     O       (key만)    	|     O     (key만)    	|       X      	|     O     (key만)    	|             	|

#### is 비교 연산자
- 매모리 내에서 같은 객체를 참조하는지 확인
- == 는 동등성(equality), is 는 식별성(identity)
- 값을 비교하는 == 와 다름

### 논리 연산자

|     기호    	|      연산자     	|                                        내용                                       	|
|:-----------:	|:---------------:	|:---------------------------------------------------------------------------------:	|
|      and    	|      논리곱     	|       두   피연산자 모두 True인   경우에만      전체   표현식을 True로   평가     	|
|      or     	|      논리합     	|     두   피연산자 중 하나라도 True인   경우      전체   표현식을 True로   평가    	|
|      not    	|     논리부정    	|                               단일   피연산자를 부정                              	|

#### 단축평가 동작
- and
    - 첫 번째 피연산자가 False인 경우, 전체 표현식은 False로 결정. <br>두 번째 피연산자는 평가되지 않고 그 값이 무시
    - 첫 번째 피연산자가 True인 경우, 전체 표현식의 결과는 두 번째 피연산자에 의해 결정. <br>두 번째 피연산자가 평가되고 그 결과가 전체 표현식의 결과로 반환
- or
    - 첫 번째 피연산자가 True인 경우, 전체 표현식은 True로 결정. <br>두 번째 피연산자는 평가되지 않고 그 값이 무시
    - 첫 번째 피연산자가 False인 경우, 전체 표현식의 결과는 두 번째 피연산자에 의해 결정. <br>두 번째 피연산자가 평가되고 그 결과가 전체 표현식의 결과로 반환

### 멤버십 연산자
- 특정 값이 시퀀스나 다른 컬렉션에 속하는지 여부를 확인

|       기호      	|                                    내용                                  	|
|:---------------:	|:------------------------------------------------------------------------:	|
|        in       	|        왼쪽   피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인      	|
|     not   in    	|     왼쪽   피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는지를 확인    	|

### 연산자 우선순위

|     우선순위    	|             연산자            	|               내용             	|
|:---------------:	|:-----------------------------:	|:------------------------------:	|
|       높음      	|               ()              	|        소괄호   grouping       	|
|                 	|               []              	|        인덱싱,   슬라이싱      	|
|                 	|               **              	|             거듭제곱           	|
|                 	|             +,   -            	|     단항   연산자 양수/음수    	|
|                 	|          *,   /, //, %        	|          산술   연산자         	|
|                 	|             +,   -            	|          산술   연산자         	|
|                 	|     <,   <=, >, >=, ==, !=    	|          비교   연산자         	|
|                 	|          is,   is not         	|           객체   비교          	|
|                 	|          in,   not in         	|         멤버십   연산자        	|
|                 	|               not             	|           논리   부정          	|
|                 	|               and             	|            논리   AND          	|
|       낮음      	|               or              	|            논리   OR           	|

### 매개변수와 인자
#### 매개변수 `parameter`
함수를 정의할 때, 
함수가 받을 값을 나타내는 변수

#### 인자 `argument`
함수를 호출할 때, 
실제로 전달되는 값

### 인자의 종류
#### Positional Arguments (위치인자)
- 함수 호출 시 인자의 위치에 따라 전달되는 인자
- > <span style='color:red;'>위치인자는 함수 호출 시 반드시 값을 전달해야 함</span>

    ```python
    def greet(name, age):
        print(f'안녕하세요, {name}님! {age}살이시군요.')


    greet('Alice', 25) # 안녕하세요, Alice님! 25살이시군요
    ```

#### Default Argument Values (기본 인자 값)
- 함수 정의에서 매개변수에 기본 값을 할당하는 것
- 함수 호출 시 인자를 전달하지 않으면, 기본값이 매개변수에 할당됨

    ```python
    def greet(name, age=30):
        print(f'안녕하세요, {name}님! {age}살이시군요.')


    greet('Bob') # 안녕하세요, Bob님! 30살이시군요.
    greet('Charlie', 40) # 안녕하세요, Charlie님! 40살이시군요.
    ```

####  Keyword Arguments (키워드 인자)
- 함수 호출 시 인자의 이름과 함께 값을 전달하는 인자
- 매개변수와 인자를 일치시키지 않고, 특정 매개변수에 값을 할당할 수 있음
- 인자의 순서는 중요하지 않으며, 인자의 이름을 명시하여 전달
- > <span style='color:red;'>단, 호출 시 키워드 인자는 위치 인자 뒤에 위치해야 함</span>

    ```python
    def greet(name, age):
        print(f'안녕하세요, {name}님! {age}살이시군요.')


    greet(name='Dave', age=35)  # 안녕하세요, Dave님! 35살이시군요.
    greet(age=35, 'Dave')  #  positional argument follows keyword argument
    ```

#### Arbitrary Argument Lists (임의의 인자 목록)
- 정해지지 않은 개수의 인자를 처리하는 인자
- 함수 정의 시 매개변수 앞에 <span style='color:red;'>‘*’</span>를 붙여 사용하며, 여러 개의 인자를 tuple로 처리
#### Arbitrary Keyword Argument Lists (임의의 키워드 인자 목록)
- 정해지지 않은 개수의 키워드 인자를 처리하는 인자
- 함수 정의 시 매개변수 앞에 <span style='color:red;'>‘**’</span>를 붙여 사용하며, <br>여러 개의 인자를 dictionary로 묶어 처리

#### 이름 검색 규칙(Name Resolution)
- 파이썬에서 사용되는 이름(식별자)들은 특정한 이름공간(namespace)에 저장되어 있음
- 아래와 같은 순서로 이름을 찾아 나가며, LEGB Rule이라고 부름
    1. Local scope : 지역 범위(현재 작업 중인 범위)
    2. Enclosed scope : 지역 범위 한 단계 위 범위
    3. Global scope : 최상단에 위치한 범위
    4. Built-in scope : 모든 것을 담고 있는 범위(정의하지 않고 사용할 수 있는 모든 것)
> <span style='color:red;'>함수 내에서는 바깥 Scope의 변수에 접근 가능하나 수정은 할 수 없음</span>

![image](https://github.com/ragu6963/TIL/assets/32388270/15b4f0c6-7f21-4986-8349-fd8740e49573)

#### LEGB Rule 예시 2
```python
a = 1
b = 2


def enclosed():
    a = 10
    c = 3

    def local(c):
        print(a, b, c) # 10 2 500

    local(500)
    print(a, b, c) # 10 2 3


enclosed()
print(a, b) # 1 2
```

- 매개변수에 global 사용 불가 

#### 재귀 함수 특징
- 특정 알고리즘 식을 표현할 때 변수의 사용이 줄어들며, 코드의 가독성이 높아짐
- 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성

## 유용한 함수
### 유용한 내장 함수
#### map(function, iterable)
순회 가능한 데이터구조(iterable)의 모든 요소에 함수를 적용하고, <br>그 결과를 map object로 반환
#### zip(*iterables)
임의의 iterable을 모아 튜플을 원소로 하는 zip object를 반환

#### lambda 함수 예시
- 간단한 연산이나 함수를 한 줄로 표현할 때 사용
- 함수를 매개변수로 전달하는 경우에도 유용하게 활용

    ```python
    # 람다 함수 미적용 코드
    def addition(x, y):
        return x + y

    result = addition(3, 5)
    print(result) # 8
    ```

    ```python
    # 람다 함수 적용 코드
    addition = lambda x, y: x + y

    result = addition(3, 5)
    print(result) # 8
    ```

### Packing `패킹`
- 여러 개의 값을 하나의 변수에 묶어서 담는 것
- 변수에 담긴 값들은 튜플(tuple) 형태로 묶임

### Unpacking `언패킹`
- 패킹된 변수의 값을 개별적인 변수로 분리하여 할당하는 것
- `*` 는 리스트의 요소를 언패킹
- `**` 는 딕셔너리의 키-값 쌍을 함수의 키워드 인자로 언패킹

    ```python
    def my_function(x, y, z):
        print(x, y, z)


    my_dict = {'x': 1, 'y': 2, 'z': 3}
    my_function(**my_dict)  # 1 2 3
    ```

#### 모듈
- 내장 함수 help를 사용해 모듈에 무엇이 들어있는지 확인 가능
- ‘<span style='color:red;'>. (dot)</span>’은<br>“점의 왼쪽 객체에서 점의 오른쪽 이름을 찾아라“ 라는 의미의 연산자
- <span style='color:red;'>from</span> 절을 활용해 특정 모듈을 미리 참조하고 어떤 요소를 import 할지 명시 `from math import pi`
- > <span style='color:red;'>만약 서로 다른 모듈이 같은 이름의 함수를 제공할 경우 문제 발생
- 마지막에 import된 이름으로 대체됨

## 제어문
### 제어문 `Control Statement`
코드의 실행 흐름을 제어하는 데 사용되는 구문<br>
<span style='color:red;'>조건</span>에 따라 코드 블록을 실행하거나 <span style='color:red;'>반복</span>적으로 코드를 실행 

## 조건문
### 개요
#### 조건문 `Conditional Statement`
주어진 조건식을 평가하여 해당 조건이 참(True)인 경우에만 <br>
코드 블록을 실행하거나 건너뜀

## 반복문
### 개요
#### 반복문 `Loop Statement`
- 주어진 코드 블록을 여러 번 반복해서 실행하는 구문
1. 특정 작업을 반복적으로 수행
2. 주어진 조건이 참인 동안 반복해서 실행

#### 반복 가능한 객체 `iterable`
반복문에서 순회할 수 있는 객체<br>
(시퀀스 객체 뿐만 아니라 dict, set 등도 포함)

### ‘while’ statement
- 주어진 조건식이 참(True)인 동안 코드를 반복해서 실행<br>
== 조건식이 거짓(False)가 될 때 까지 반복
- while statement의 기본 구조

    ```python
    while 조건식:
        코드 블록
    ```

#### while 문은 반드시 <br> <span style='color:red;'>종료 조건</span>이 필요

#### for / while
- 파이썬 반복문에 사용되는 키워드
    - for
        - iterable의 요소를 하나씩 순회하며 반복
    - while
        - 주어진 조건식이 참인 동안 반복

#### 적절한 반복문 활용하기
- for
    - 반복 횟수가 명확하게 정해져 있는 경우에 유용
    - 예를 들어 리스트, 튜플, 문자열 등과 같은 시퀀스 형식의 데이터를 처리할 때 

- while
    - 반복 횟수가 불명확하거나 조건에 따라 반복을 종료해야 할 때 유용
    - 예를 들어 사용자의 입력을 받아서 특정 조건이 충족될 때까지 반복하는 경우

### 반복 제어
for문과 while은 매 반복마다 본문 내 모든 코드를 실행하지만<br>
때때로 일부만 실행하는 것이 필요할 때가 있음

#### break
반복을 즉시 중지

#### continue
다음 반복으로 건너뜀
#### continue 예시
- 리스트에서 홀수만 출력하기
> <span style='color:red;'>현재 반복문의 남은 코드를 건너뛰고 다음 반복으로 넘어감</span>

    ```python
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    for num in numbers:
        if num % 2 == 0:
            continue
        print(num)
        
    """
    1
    3
    5
    7
    9
    """
    ```

#### break와 continue 주의사항
- break와 continue를 남용하는 것은 코드의 가독성을 저하시킬 수 있음
- <span style='color:red;'>특정한 종료 조건</span>을 만들어 break을 대신하거나,<br> <span style='color:red;'>if 문을 사용</span>해 continue 처럼 코드를 건너 뛸 수도 있음
- 약간의 시간이 들더라도 가능한 코드의 가독성을 유지하고 코드의 의도를<br> 명확하게 작성하도록 노력하는 것이 중요

#### List Comprehension 구조
```python
[expression for 변수 in iterable]

list(expression for 변수 in iterable)
```

#### List Comprehension 활용
- 사용 전
    ```python
    numbers = [1, 2, 3, 4, 5]
    squared_numbers = []

    for num in numbers:
        squared_numbers.append(num**2)

    print(squared_numbers)  # [1, 4, 9, 16, 25]
    ```

- 사용 후
    ```python
    numbers = [1, 2, 3, 4, 5]
    squared_numbers = [num**2 for num in numbers]

    print(squared_numbers)  # [1, 4, 9, 16, 25]
    ```

### enumerate(iterable, start=0) 
iterable 객체의 각 요소에 대해 인덱스와 <br>함께 반환하는 내장함수
