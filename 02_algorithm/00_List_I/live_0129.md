# 알고리즘
문제를 해결하기 위한 절차나 방법

## 알고리즘 표현
1. 의사코드(슈도코드)
2. 순서도 (잘 쓰진 않는다.)

## 좋은 알고리즘
1. 정확성: 얼마나 정확하게 동작하는가
2. 작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가
3. 메모리 사용량: 얼마나 적은 메모리를 사용하는가
4. 단순성: 얼마나 단순한가
5. 최적성: 더 이상 개선할 여지없이 최적화되었는가
  > 많은 문제에서 알고리즘의 작업량을 비교하여 성능을 분석한다.

### 예: 1부터 100까지 합을 구하는 문제
```py
# 수도 코드
S <- 0
for i : 1 -> 100
    S <- S + i
```

## 시간 복잡도
- 알고리즘의 작업량을 표현할 때 사용
- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산

### 빅-오(O) 표기법
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- 계수는 생략하여 표시
- 예)
> O(3n + 2) = O(3n) = O(n)
>
> 최고차항 (3n)만 선택
> 
> 계수 3 제거

> O(2n^ + 10n + 100) = O(n^)
>
> O(4) = O(1)

```py
arr=[1,2,3]
print(arr) # [1,2,3]
print(*arr) # 1,2,3
# unpack 사용
```

# 버블 정렬
- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
- 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
- 시간 복잡도: `O(n^)`

## 버블 정렬 코드
```
# 수도 코드
BubbleSort(a, N)                # 정렬할 배열과 배열의 크기
    for i : N-1 -> 1            # 정렬될 구간의 끝
        for j : 0 -> i-1        # 비교할 원소 중 왼쪽 원소의 인덱스
            if a[j] > a[j+1]    # 왼쪽 원소가 더 크면
                a[j] <-> a[j+1] # 오른쪽 원소와 교환
```
```python
def BubbleSort(a, N):           # 정렬할 List, N 원소 수
    for i in range(N-1, 0, -1): # 범위의 끝 위치
        for j in range(0, i):   # 비교할 왼쪽 원소
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```
